1. #### **隐式转换和显示转换的区别，以及他们各自的特点**？

   > - **隐式转换**也叫**自动类型转换**，指的是不需要调用函数，JVM自动将类型转换的一种方式。因为这种类型转换经常使用，Java语言在设计时，为了减轻开发人员的负担，都交给JVM来自动处理。
   >
   >   取值范围从小的数据类型 转向 取值范围大的数据类型；
   >
   >   byte—> short,char—> int —> long—> float —> double
   >
   > - **显示转换**也叫**强制类型转换**，指的是需要手动去处理才能完成的类型转换。**该转换会存在精度损失**。
   >
   >   取值范围大的数据类型 转向 取值范围小的数据类型；
   >
   >   转换规则为： a = (a的数据类型）b
   >
   >   double→float→long→int→short(char)→byte

2. #### **Java 中的几种基本数据类型了解么**？

   > Java 中有 8 种基本数据类型，分别为：
   >
   > - 6 种数字类型：
   >
   >   - 4 种整数型：`byte`、`short`、`int`、`long`
   >   - 2 种浮点型：`float`、`double`
   >
   > - 1 种字符类型：`char`
   >
   > - 1 种布尔型：`boolean`。
   >
   >   这 8 种基本数据类型的默认值以及所占空间的大小如下（对于 `boolean`，官方文档未明确定义，它依赖于 JVM 厂商的具体实现）：
   >
   >   | 基本类型  | 位数 | 字节 | 默认值  | 取值范围                                   |
   >   | :-------- | :--- | :--- | :------ | ------------------------------------------ |
   >   | `byte`    | 8    | 1    | 0       | -128 ~ 127                                 |
   >   | `short`   | 16   | 2    | 0       | -32768 ~ 32767                             |
   >   | `int`     | 32   | 4    | 0       | -2147483648 ~ 2147483647                   |
   >   | `long`    | 64   | 8    | 0L      | -9223372036854775808 ~ 9223372036854775807 |
   >   | `char`    | 16   | 2    | 'u0000' | 0 ~ 65535                                  |
   >   | `float`   | 32   | 4    | 0f      | 1.4E-45 ~ 3.4028235E38                     |
   >   | `double`  | 64   | 8    | 0d      | 4.9E-324 ~ 1.7976931348623157E308          |
   >   | `boolean` | 1    |      | false   | true、false                                |
   >
   >   另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一。

3. #### **包装器类型，什么是自动拆箱什么是自动装箱** ？

   > 八种基本类型都有对应的包装类分别为：`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean`。
   >
   > - **装箱**：将基本类型用它们对应的引用类型包装起来；
   >
   > - **拆箱**：将包装类型转换为基本数据类型；
   >
   > - 从字节码中，我们发现装箱其实就是调用了 包装类的`valueOf()`方法，拆箱其实就是调用了 `xxxValue()`方法。
   >
   >   因此，
   >
   >   - `Integer i = 10` 等价于 `Integer i = Integer.valueOf(10)`
   >   - `int n = i` 等价于 `int n = i.intValue()`;
   >
   >   注意：**如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。**
   >
   >   Java 基本数据类型的包装类型的大部分都用到了**缓存机制**来提升性能。
   >
   >   `Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。
   >
   >   以Integer为例，如果整数的大小不在这个范围内的话，那么valueof()方法会新new一个Integer类型的对象，并返回。
   >
   >   ```
   >   //
   >   public static Integer valueOf(int i) {
   >       if (i >= IntegerCache.low && i <= IntegerCache.high)
   >           return IntegerCache.cache[i + (-IntegerCache.low)];
   >       return new Integer(i);
   >   }
   >   
   >   //
   >   public static Double valueOf(String s) throws NumberFormatException {
   >   	return new Double(parseDouble(s));
   >   }
   >   ```

4. ####  **Java常用的类有哪些**？ 

   > Java中常用的类有Object 类、String类；
   >
   > Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：
   >
   > ```java
   > /**
   >  * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。
   >  */
   > public final native Class<?> getClass()
   > /**
   >  * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。
   >  */
   > public native int hashCode()
   > /**
   >  * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。
   >  */
   > public boolean equals(Object obj)
   > /**
   >  * naitive 方法，用于创建并返回当前对象的一份拷贝。
   >  */
   > protected native Object clone() throws CloneNotSupportedException
   > /**
   >  * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。
   >  */
   > public String toString()
   > /**
   >  * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
   >  */
   > public final native void notify()
   > /**
   >  * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
   >  */
   > public final native void notifyAll()
   > /**
   >  * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。
   >  */
   > public final native void wait(long timeout) throws InterruptedException
   > /**
   >  * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。
   >  */
   > public final void wait(long timeout, int nanos) throws InterruptedException
   > /**
   >  * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
   >  */
   > public final void wait() throws InterruptedException
   > /**
   >  * 实例被垃圾回收器回收的时候触发的操作
   >  */
   > protected void finalize() throws Throwable { }
   > ```

   #### == 和 equals() 的区别

   **`==`** 对于基本类型和引用类型的作用效果是不同的：

   - 对于基本数据类型来说，`==` 比较的是值。
   - 对于引用数据类型来说，`==` 比较的是对象的内存地址。

   > 因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。

   **`equals()`** 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。`equals()`方法存在于`Object`类中，而`Object`类是所有类的直接或间接父类，因此所有的类都有`equals()`方法。

   `Object` 类 `equals()` 方法：

   ```java
   public boolean equals(Object obj) {
        return (this == obj);
   }
   ```

   `equals()` 方法存在两种使用情况：

   - **类没有重写 `equals()`方法** ：通过`equals()`比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 `Object`类`equals()`方法。
   - **类重写了 `equals()`方法** ：一般我们都重写 `equals()`方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。

   `String` 中的 `equals` 方法是被重写过的，因为 `Object` 的 `equals` 方法是比较的对象的内存地址，而 `String` 的 `equals` 方法比较的是对象的值。

   ```java
   // String中的equals方法
   public boolean equals(Object anObject) {
       if (this == anObject) {
           return true;
       }
       if (anObject instanceof String) {
           String anotherString = (String)anObject;
           int n = value.length;
           if (n == anotherString.value.length) {
               char v1[] = value;
               char v2[] = anotherString.value;
               int i = 0;
               while (n-- != 0) {
                   if (v1[i] != v2[i])
                       return false;
                   i++;
               }
               return true;
           }
       }
       return false;
   }
   
   // Object中的equals方法
   public boolean equals(Object obj) {
   	return (this == obj);
   }
   ```

5. #### spring的常用注解** ? 

6. #### **mysql的默认数据库引擎，innodb和myiasm的区别**？

7. ####  **什么是多态**？ 

8. #### **什么是跨域问题**? 

9. **说一说String StringBuffer的区别以及用途**? 

10. **索引的分类**? 

11. **mybatis中#{}和${}的区别**? 

12. #### 设计模式？

    > **一、什么是设计模式**
    >
    > [设计模式](https://so.csdn.net/so/search?q=设计模式&spm=1001.2101.3001.7020)（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。简单说：
    >
    > **模式：在某些场景下，针对某类问题的某种通用的解决方案。**
    >
    > 场景：项目所在的环境
    >
    > 问题：约束条件，项目目标等
    >
    > 解决方案：通用、可复用的设计，解决约束达到目标。
    >
    > **二、设计模式的三个分类**
    >
    > **创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。**
    >
    > **结构型模式：把类或对象结合在一起形成一个更大的结构。**
    >
    > **行为型模式：类和对象如何交互，及划分责任和算法。**
    >
    > ![img](https://img-blog.csdnimg.cn/img_convert/aefc6eb7f5ba13216d5f21051327816e.png)
    >
    > 

13. **单例模式的分类**? 

14. **ArrayList 和linkList的区别**？

15. **mybatis的动态标签的作用以及有哪些动态标签**? 

16. **如果有一条sql语句执行的很慢,怎么进行优化**？

17. **什么是字节码?采用字节码的好处是什么**?

    > 在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。
    >
    > ![image-20220706221621350](C:\Users\LHJ\AppData\Roaming\Typora\typora-user-images\image-20220706221621350.png)
    >
    > 我们需要格外注意的是 `.class->机器码` 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 **Java 是编译与解释共存的语言** 。

18.  **为什么说 Java 语言“编译与解释并存”**？ 

    > 我们可以将高级编程语言按照程序的执行方式分为两种：
    >
    > - **编译型** ：[编译型语言open in new window](https://zh.wikipedia.org/wiki/編譯語言) 会通过[编译器open in new window](https://zh.wikipedia.org/wiki/編譯器)将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。
    >
    > - **解释型** ：[解释型语言open in new window](https://zh.wikipedia.org/wiki/直譯語言)会通过[解释器open in new window](https://zh.wikipedia.org/wiki/直譯器)一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。
    >
    > - ![编译型语言和解释型语言](https://javaguide.cn/assets/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80.9908e5e6.png)
    >
    >   答：这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（`.class` 文件），这种字节码必须由 Java 解释器来解释执行。
    >
    >   在常见的HotSpot虚拟机中，为了避免解释型语言带来的执行效率低问题，采用了jit compile(just in time compilation)技术，将运行频率很高的字节码直接编译为机器指令执行来提高性能。
    >
    >   ![img](https://pics5.baidu.com/feed/faf2b2119313b07e871418e642a5df2b96dd8c29.jpeg?token=8cca29b8ddc9f076747211710cc1740d)

19. **一个类的构造方法的作用是什么，若一个类没有声明构造方法，该程序能正确执行吗？为什么**？ 

20. **字符型常量和字符串常量的区别**? 

21. **静态方法为什么不能调用非静态成员**? 

22. #### **Java8有哪些新特性**？

    > 1. 较 jdk1.7 **，interface 里可以有静态方法，并且可以有方法体**；
    >
    > - `default`修饰的方法，是普通实例方法，可以用`this`调用，可以被子类继承、重写。
    >
    > - static`修饰的方法，使用上和一般类静态方法一样。但它不能被子类继承，只能用`Interface`调用。
    >
    > 既然 interface 也可以有自己的方法实现，似乎和 abstract class 没多大区别了。其实它们还是有区别的，interface 和 class 的区别，主要有：
    >
    > ​		接口多实现，类单继承；
    >
    > ​		接口的方法是 public abstract 修饰，变量是 public static final 修饰。 abstract class 可以用其他修饰符；
    >
    > ​	interface 的方法是更像是一个扩展插件。而 abstract class 的方法是要继承的。
    >
    > 2. **functional interface 函数式接口**
    >
    > **定义**：也称 SAM 接口，即 Single Abstract Method interfaces，有且只有一个抽象方法，但可以有多个非抽象方法的接口。
    >
    > 3. **Lambda 表达式**
    >
    >    使用 Lambda 表达式可以使代码变的更加简洁紧凑。让 java 也能支持简单的*函数式编程*。
    >
    > 4. **Stream**
    >
    >    java 新增了 `java.util.stream` 包，它和之前的流大同小异。之前接触最多的是资源流，比如`java.io.FileInputStream`，通过流把文件从一个地方输入到另一个地方，它只是内容搬运工，对文件内容不做任何*CRUD*。
    >
    >    `Stream`依然不存储数据，不同的是它可以检索(Retrieve)和逻辑处理集合数据、包括筛选、排序、统计、计数等。可以想象成是 Sql 语句。
    >
    >    它的源数据可以是 `Collection`、`Array` 等。由于它的方法参数都是函数式接口类型，所以一般和 Lambda 配合使用。
    >
    >    1. stream 串行流
    >    2. parallelStream 并行流，可多线程执行
    >
    > 5.  **Optional**
    >
    >    在[阿里巴巴开发手册关于 Optional 的介绍open in new window](https://share.weiyun.com/ThuqEbD5)中这样写到：
    >
    >    > 防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：
    >    >
    >    > 1） 返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。
    >    >
    >    > 反例：public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。
    >    >
    >    > 2） 数据库的查询结果可能为 null。
    >    >
    >    > 3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。
    >    >
    >    > 4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。
    >    >
    >    > 5） 对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。
    >    >
    >    > 6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。
    >    >
    >    > 正例：使用 JDK8 的 Optional 类来防止 NPE 问题。
    >
    > 6. **Date-Time API**
    >
    >    这是对`java.util.Date`强有力的补充，解决了 Date 类的大部分痛点：
    >
    >    1. 非线程安全
    >    2. 时区处理麻烦
    >    3. 各种格式化、和时间计算繁琐
    >    4. 设计有缺陷，Date 类同时包含日期和时间；还有一个 java.sql.Date，容易混淆。
    >
    >    

23. **数组 (Array) 和列表 (ArrayList) 有什么区别？什么时候应该使用 Array 而不是ArrayList**？

24. **MySQL 中有哪几种锁**？

25. **谈谈自己对于 Spring IoC 的了解**？

26. **谈谈自己对于 AOP 的了解**？

27. **将一个类声明为 bean 的注解有哪些**?

28. **说说bean 的生命周期**?

29. **SpringMVC的工作原理有了解嘛**？

30. **Spring 框架中用到了哪些设计模式**？

31. **Spring 事务中有哪几种事务传播行为**?

32. #### java面向对象的三大特征？

    > #### 封装
    >
    > 封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。
    >
    > #### 继承
    >
    > 不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。
    >
    > **关于继承如下 3 点请记住：**
    >
    > 1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。
    > 2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
    > 3. 子类可以用自己的方式实现父类的方法。
    >
    > #### 多态
    >
    > 多态，顾名思义，表示一个对象具有多种的状态，具体表现为**父类的引用指向子类的实例**。
    >
    > **多态的特点:**
    >
    > - 对象类型和引用类型之间具有继承（类）/实现（接口）的关系；
    > - 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；
    > - 多态不能调用“只在子类存在但在父类不存在”的方法；
    > - 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。

33. #### 重写与重载的区别？

    > 重写和重载的区别主要有如下几点：
    > 1、定义不同：重载是定义相同的方法名、参数不同，重写是子类重写父类的方法
    > 2、范围不同：重载是在一个类中，重写是子类与父类之间的
    > 3、多态不同：重载是编译时的多态性，重写是运行时的多态性
    > 4、参数不同：重载的参数个数、参数类型、参数的顺序可以不同，重写父类子方法参数必须相同
    > 5、修饰不同：重载对修饰范围没有要求，重写要求重写方法的修饰范围大于被重写方法的修饰范围
    >
    > 多态是一个类需要表现出多种形态，子类重写父类的方法，使子类具有不同的方法实现

34. **接口和抽象类的区别**? 

35. **说说集合的种类**？

36. **HashMap底层实现**？ 

37. **解决哈希冲突的几种办法是什么**?

38. **ConcurrentHashMap和Hashtable 的区别** ？

39. #### **多线程知道吗,大概说说**？ 

    > **一个 Java 程序的运行是 main 线程和多个其他线程同时运行**。
    >
    > ![img](https://javaguide.cn/assets/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.dbbe1f77.png)
    >
    > 从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的**堆**和**方法区 (JDK1.8 之后的元空间)\**资源，但是每个线程有自己的\**程序计数器**、**虚拟机栈** 和 **本地方法栈**。
    >
    > **总结：** **线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。**
    >
    > 程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**；
    >
    > - **虚拟机栈：** 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
    > - **本地方法栈：** 和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。
    >
    > 所以，为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的

40. #### **多线程的线程池讲一下,好处是什么**?

    > **线程池**提供了一种限制和管理资源（包括执行一个任务）的方式。 每个**线程池**还维护一些基本统计信息，例如已完成任务的数量。
    >
    > **使用线程池的好处**：
    >
    > - **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
    > - **提高响应速度**。当任务到达时，任务可以不需要等到线程创建就能立即执行。
    > - **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

41. **多线程的实现方式**？

42. **多线程线程池的参数都有什么,有哪些作用**? 

43. **多线程的拒绝策略有哪些?详细说说**？

44. **ThreadLocal 原理和内存泄漏问题说说**？

    

45. **说说spring和springboot的特点**？

46. **Spring Boot 常用注解**？

47. **单例 bean 的线程安全问题了解吗**？

48. **数据库的事务都有哪些, 用什么来保证这些特征**？

49. **知道redis吗,Redis Stream消费者崩溃带来的会不会消息丢失问题**？

50. **说说Redis哈希槽的概念**？

51. **Redis文件事件的模型,详细说说**？

